# 员工客户端用户活动时间计算分析报告

**分析时间**: 2025-01-16
**分析范围**: employee-client 整体架构
**分析重点**: 活动时间计算方法与数据准确性
**当前端**: employee-client

---

## 执行摘要

员工客户端通过多层次的数据收集机制来准确计算用户活动时间。系统采用**原生事件监听 + 空闲检测 + 时间累积**的三重验证机制，确保活动时间计算的准确性和可靠性。核心机制包括真实键盘鼠标事件捕获、系统空闲时间检测、以及基于时间窗口的活动周期累积算法。

**关键发现**:
- ✅ 使用原生系统 API 进行真实事件监听，数据可信度高
- ✅ 采用活动时间与空闲时间双轨计算，互为验证
- ✅ 基于可配置的时间间隔进行数据累积和上传
- ⚠️ 活动时间计算依赖于事件触发频率和空闲阈值配置
- ⚠️ Windows 平台需要管理员权限，macOS 需要辅助功能权限

---

## 分析目标

本次分析旨在深入理解员工客户端如何从底层系统事件中准确推导出用户的活动时间，包括：

1. 数据收集的技术实现方式
2. 活动时间与空闲时间的计算逻辑
3. 不同平台的实现差异
4. 数据准确性的保障机制
5. 潜在的准确性影响因素

---

## 详细分析

### 1. 数据收集架构

#### 1.1 三层架构设计

员工客户端采用清晰的三层架构收集用户活动数据：

```
┌─────────────────────────────────────────────────────────────┐
│              ActivityCollectorService (业务层)               │
│  - 配置管理 (activityInterval, idleThreshold)                │
│  - 数据累积 (keystrokes, mouseClicks, activeTime, idleTime) │
│  - 定时上传 (uploadInterval)                                 │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ↓
┌─────────────────────────────────────────────────────────────┐
│           Platform Adapters (平台适配层)                     │
│  - DarwinAdapter (macOS) - NativeEventAdapter               │
│  - WindowsAdapter (Windows) - WindowsNativeEventAdapter     │
│  - 提供统一的事件监听接口                                     │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ↓
┌─────────────────────────────────────────────────────────────┐
│              Native Modules (原生模块层)                      │
│  - macOS: CGEventTap (Objective-C/Swift)                    │
│  - Windows: SetWindowsHookEx (C++ Win32 API)               │
│  - 底层系统事件捕获                                          │
└─────────────────────────────────────────────────────────────┘
```

**核心原理**: 通过系统级别的事件钩子（Hook）捕获所有键盘和鼠标事件，不依赖应用层模拟或推断。

#### 1.2 核心数据收集服务

**ActivityCollectorService** (activity-collector-service.ts:36-548)

这是活动时间计算的核心服务，负责：

```typescript
export interface ActivityData {
  keystrokes: number;           // 键盘按键次数
  mouseClicks: number;          // 鼠标点击次数
  mouseMoves: number;           // 鼠标移动次数
  scrollEvents: number;         // 滚动事件次数
  activeTime: number;           // 活跃时间（毫秒）⭐
  idleTime: number;             // 空闲时间（毫秒）⭐
  intervalDuration: number;     // 收集间隔（毫秒）
  windowTitle?: string;         // 当前窗口标题
  processName?: string;         // 当前进程名
  timestamp: Date;              // 时间戳
}
```

**关键配置参数**:
```typescript
export interface ActivityCollectorConfig {
  activityInterval: number;      // 活动采集间隔（默认60000ms = 1分钟）
  enableActivity: boolean;        // 是否启用活动监控
  enableIdleDetection: boolean;   // 是否启用空闲检测
  idleThreshold: number;          // 空闲阈值（默认30000ms = 30秒）
}
```

---

### 2. 活动时间计算核心逻辑

#### 2.1 活动时间累积算法

**位置**: activity-collector-service.ts:384-398

```typescript
private updateLastActivityTime(): void {
  this.lastActivityTime = Date.now();
}

private updateActiveTime(): void {
  if (!this.isCurrentlyIdle) {
    const now = Date.now();
    const timeSinceLastActivity = now - this.lastActivityTime;

    // 只有在合理的时间范围内才累积活跃时间
    if (timeSinceLastActivity < this.config.idleThreshold) {
      this.accumulatedData.activeTime += timeSinceLastActivity;
    }
  }
}
```

**计算原理**:

1. **事件驱动更新**: 每次键盘或鼠标事件发生时触发
   ```typescript
   // 键盘事件处理器 (activity-collector-service.ts:330-338)
   private handleKeyboardEvent(data: any): void {
     if (!this.isCollecting) return;

     this.accumulatedData.keystrokes++;
     this.updateLastActivityTime();    // 更新最后活动时间
     this.updateActiveTime();          // 累积活跃时间
   }

   // 鼠标事件处理器 (activity-collector-service.ts:340-363)
   private handleMouseEvent(data: any): void {
     if (!this.isCollecting) return;

     switch (data.type) {
       case 'click':
         this.accumulatedData.mouseClicks++;
         break;
       case 'move':
         this.accumulatedData.mouseMoves++;
         break;
       case 'scroll':
         this.accumulatedData.scrollEvents++;
         break;
     }

     this.updateLastActivityTime();
     this.updateActiveTime();
   }
   ```

2. **时间差计算**: 计算当前时间与上次活动时间的差值
   - 如果差值 < `idleThreshold` (30秒)，则认为用户持续活动
   - 将此时间差累加到 `activeTime`

3. **防护机制**: 防止异常的长时间累积
   - 超过空闲阈值的时间不计入活跃时间
   - 确保活跃时间的准确性

**示例场景**:

```
时间线:
T0 (0ms)   - 用户按下键盘 → lastActivityTime = 0ms
T1 (1000ms) - 用户移动鼠标 → activeTime += 1000ms, lastActivityTime = 1000ms
T2 (3000ms) - 用户点击鼠标 → activeTime += 2000ms, lastActivityTime = 3000ms
T3 (35000ms) - 用户按键 → 时间差 = 32000ms > 30000ms (超过阈值)
                        → activeTime 不变 (因为中间可能空闲)
                        → lastActivityTime = 35000ms

最终 activeTime = 3000ms (1000 + 2000)
```

#### 2.2 空闲时间检测机制

**位置**: activity-collector-service.ts:365-382

```typescript
private handleIdleStateChange(isIdle: boolean): void {
  if (!this.isCollecting) return;

  const now = Date.now();
  const timeDiff = now - this.lastActivityTime;

  if (isIdle && !this.isCurrentlyIdle) {
    // 变为空闲状态
    this.isCurrentlyIdle = true;
    console.log('[ACTIVITY_COLLECTOR] User became idle');
  } else if (!isIdle && this.isCurrentlyIdle) {
    // 从空闲状态恢复
    this.isCurrentlyIdle = false;
    this.accumulatedData.idleTime += timeDiff;  // 累积空闲时间
    this.updateLastActivityTime();
    console.log('[ACTIVITY_COLLECTOR] User became active again', { idleTime: timeDiff });
  }
}
```

**空闲检测原理**:

1. **原生系统API检测**:
   - macOS: `ioreg -c IOHIDSystem | grep HIDIdleTime` (darwin-adapter.ts:692-707)
   - Windows: `GetLastInputInfo()` Win32 API (wmi-activity-inferrer.ts:166-200)

2. **状态转换**:
   ```
   活动状态 (isCurrentlyIdle = false)
         ↓ (30秒无输入)
   空闲状态 (isCurrentlyIdle = true)
         ↓ (检测到输入)
   活动状态 (isCurrentlyIdle = false, idleTime += 空闲时长)
   ```

3. **双重验证**:
   - `activeTime` + `idleTime` ≈ `intervalDuration`
   - 互为验证，确保时间计算的准确性

---

### 3. 平台特定实现

#### 3.1 macOS 平台 (DarwinAdapter)

**原生事件监听**: darwin-adapter.ts:250-437

**技术实现**:
- 使用 CGEventTap API 监听全局键盘鼠标事件
- 需要用户授权"辅助功能"权限
- 事件监听代码位于 `platforms/darwin/native-event-adapter.ts`

**事件计数方式**:
```typescript
// darwin-adapter.ts:126-149
private async getKeystrokeCount(): Promise<number> {
  // 检查原生事件适配器状态
  const nativeStatus = this.nativeEventAdapter ? {
    isMonitoring: this.nativeEventAdapter.isMonitoring(),
    counts: this.nativeEventAdapter.getCurrentCounts()
  } : { isMonitoring: false, counts: { keyboardCount: 0, mouseCount: 0 } };

  console.log(`[DARWIN_DEBUG] 键盘计数详情:`);
  console.log(`  - 当前周期计数: ${this.currentPeriodKeystrokes}`);
  console.log(`  - 原生模块状态: ${nativeStatus.isMonitoring ? '运行中' : '未运行'}`);
  console.log(`  - 原生模块键盘计数: ${nativeStatus.counts.keyboardCount}`);

  return this.currentPeriodKeystrokes;
}
```

**数据采集流程**:
```typescript
// darwin-adapter.ts:310-335
private async collectActivityData(): Promise<any> {
  const timestamp = new Date();
  const activeWindow = await this.getActiveWindow();

  // 获取系统空闲时间
  const idleTime = await this.getSystemIdleTime();

  // 获取键盘和鼠标活动
  const keystrokes = await this.getKeystrokeCount();
  const mouseClicks = await this.getMouseClickCount();

  const activityData = {
    timestamp,
    activeWindow: activeWindow || undefined,
    keystrokes,
    mouseClicks,
    mouseMovements: 0,
    idleTime
  };

  return activityData;
}
```

**空闲时间获取** (darwin-adapter.ts:692-707):
```typescript
private async getSystemIdleTime(): Promise<number> {
  try {
    // 使用 ioreg 命令获取系统空闲时间
    const { stdout } = await execAsync('ioreg -c IOHIDSystem | grep HIDIdleTime');
    const match = stdout.match(/HIDIdleTime"=(\d+)/);
    if (match) {
      // 转换纳秒到秒
      const nanoseconds = parseInt(match[1]);
      return Math.floor(nanoseconds / 1000000000);
    }
    return 0;
  } catch (error) {
    logger.error('Failed to get system idle time', error);
    return 0;
  }
}
```

#### 3.2 Windows 平台 (WindowsAdapter)

**原生事件监听**: windows-adapter.ts:419-516

**技术实现**:
- 使用 SetWindowsHookEx Win32 API 安装全局键盘鼠标钩子
- 需要管理员权限运行
- 原生 C++ 模块位于 `native-event-monitor-win/`

**事件计数方式**:
```typescript
// windows-adapter.ts:998-1044
private async collectActivityData(): Promise<ActivityData> {
  const timestamp = new Date();

  // 获取活动窗口信息（优先使用原生C++模块）
  const activeWindow = await this.getActiveWindow();

  // 使用原生事件监控获取真实数据
  if (this.nativeEventAdapter && this.nativeEventAdapter.isAvailable()) {
    const eventData = await this.nativeEventAdapter.getEventCounts();

    if (eventData) {
      logger.info(`[WINDOWS] 📊 活动数据采集:`);
      logger.info(`[WINDOWS]   - 键盘事件: ${eventData.keyboard}`);
      logger.info(`[WINDOWS]   - 鼠标点击: ${eventData.mouseClicks}`);
      logger.info(`[WINDOWS]   - 空闲时间: ${eventData.idleTime}ms`);
      logger.info(`[WINDOWS]   - 监控状态: ${eventData.isMonitoring ? '✅' : '❌'}`);

      return {
        timestamp,
        activeWindow: activeWindow || undefined,
        keystrokes: eventData.keyboard,
        mouseClicks: eventData.mouseClicks,
        mouseMovements: 0,
        idleTime: eventData.idleTime
      };
    }
  }

  // 备用方案：推断模式（权限不足时）
  return {
    timestamp,
    activeWindow: activeWindow || undefined,
    keystrokes: 0,
    mouseClicks: 0,
    mouseMovements: 0,
    idleTime: 0
  };
}
```

**数据上传成功后重置** (windows-adapter.ts:496-515):
```typescript
public onDataUploadSuccess(): void {
  logger.info('[WINDOWS] 收到数据上传成功通知，重置活动计数器');
  try {
    if (this.nativeEventAdapter && this.nativeEventAdapter.isAvailable()) {
      this.nativeEventAdapter.resetCounts().then(result => {
        if (result) {
          logger.info('[WINDOWS] ✅ 原生事件计数器已重置');
        } else {
          logger.warn('[WINDOWS] ⚠️ 原生事件计数器重置失败');
        }
      });
    }
  } catch (error) {
    logger.error('[WINDOWS] 重置活动计数器时出错:', error);
  }
}
```

#### 3.3 Windows 推断模式 (WMIActivityInferrer)

**场景**: 当原生钩子无法安装时（权限不足、被安全软件拦截）

**推断策略** (wmi-activity-inferrer.ts:269-298):

```typescript
inferKeystrokes(indicators: SystemActivityIndicators, timeDelta: number): number {
  const weights = {
    windowFocus: 2.5,    // 窗口切换通常伴随键盘输入
    processActivity: 1.8, // 进程活动反映用户交互
    inputLanguage: 5.0,   // 输入法变化直接反映键盘使用
    lowIdle: 1.2         // 低空闲时间意味着活跃使用
  };

  let estimatedKeystrokes = 0;

  // 基于窗口焦点变化
  estimatedKeystrokes += indicators.windowFocusChanges * weights.windowFocus;

  // 基于进程活动
  const normalizedProcessActivity = Math.min(indicators.processActiveTime / 100, 10);
  estimatedKeystrokes += normalizedProcessActivity * weights.processActivity;

  // 基于输入法变化
  estimatedKeystrokes += indicators.inputLanguageChanges * weights.inputLanguage;

  // 基于空闲时间逆向推断
  if (indicators.systemIdleTime < 5000) { // 5秒内有输入
    estimatedKeystrokes += (5000 - indicators.systemIdleTime) / 1000 * weights.lowIdle;
  }

  // 时间归一化
  const timeInMinutes = timeDelta / 60000;
  estimatedKeystrokes = estimatedKeystrokes * Math.min(timeInMinutes, 1);

  return Math.round(Math.max(0, estimatedKeystrokes));
}
```

**推断指标**:
- 窗口焦点变化次数
- 进程 CPU 使用率
- 输入法切换次数
- 光标位置变化
- 系统空闲时间

**置信度评估** (wmi-activity-inferrer.ts:333-352):
```typescript
calculateConfidence(indicators: SystemActivityIndicators): number {
  const reliabilityWeights = {
    systemIdle: { weight: 0.9, value: indicators.systemIdleTime > 0 ? 1 : 0 },
    windowFocus: { weight: 0.7, value: indicators.windowFocusChanges > 0 ? 1 : 0 },
    processActivity: { weight: 0.6, value: indicators.processActiveTime > 0 ? 1 : 0 },
    cursorMovement: { weight: 0.4, value: indicators.cursorPositionVariation > 0 ? 1 : 0 },
    inputLanguage: { weight: 0.5, value: indicators.inputLanguageChanges > 0 ? 1 : 0 }
  };

  // 加权平均计算置信度
  return Math.round((confidence / totalWeight) * 100);
}
```

---

### 4. 数据上传与周期重置

#### 4.1 定时上传机制

**位置**: activity-collector-service.ts:400-412, 452-525

```typescript
// 启动上传定时器
private startUploadTimer(): void {
  this.uploadInterval = setInterval(async () => {
    if (this.isCollecting && this.hasAccumulatedData()) {
      try {
        await this.uploadAccumulatedData();
      } catch (error) {
        console.error('[ACTIVITY_COLLECTOR] Upload interval error:', error);
      }
    }
  }, this.config.activityInterval);  // 默认 60000ms (1分钟)

  console.log(`[ACTIVITY_COLLECTOR] Upload timer started with interval: ${this.config.activityInterval}ms`);
}

// 上传累积数据
private async uploadAccumulatedData(): Promise<void> {
  try {
    const now = Date.now();
    const actualDuration = now - this.collectionStartTime;

    // 更新数据
    this.accumulatedData.intervalDuration = actualDuration;
    this.accumulatedData.timestamp = new Date();

    // 获取当前窗口信息
    const windowInfo = await this.platformAdapter.getActiveWindow();
    this.accumulatedData.windowTitle = windowInfo?.title;
    this.accumulatedData.processName = windowInfo?.processName;

    console.log('[ACTIVITY_COLLECTOR] Uploading accumulated data:', {
      keystrokes: this.accumulatedData.keystrokes,
      mouseClicks: this.accumulatedData.mouseClicks,
      activeTime: this.accumulatedData.activeTime,  // ⭐ 关键字段
      duration: actualDuration
    });

    // 准备数据格式 - 匹配服务器期望的字段
    const inputActivityData = {
      timestamp: this.accumulatedData.timestamp.toISOString(),
      isActive: true,  // 有键盘鼠标事件即为活动
      keystrokes: this.accumulatedData.keystrokes,
      mouseClicks: this.accumulatedData.mouseClicks,
      idleTime: this.accumulatedData.idleTime,
      activeWindow: this.accumulatedData.windowTitle,
      activeWindowProcess: this.accumulatedData.processName,
      activityInterval: this.accumulatedData.intervalDuration
    };

    // 优先使用 WebSocket 上传，失败则使用 HTTP
    let uploadSuccess = false;

    if (this.websocketService && this.websocketService.isConnected()) {
      try {
        console.log('[ACTIVITY_COLLECTOR] ⚡ Uploading via WebSocket (real-time)');
        await this.websocketService.sendActivityData(inputActivityData);
        uploadSuccess = true;
      } catch (wsError) {
        console.error('[ACTIVITY_COLLECTOR] ❌ WebSocket upload failed, falling back to HTTP');
      }
    }

    // HTTP fallback
    if (!uploadSuccess) {
      console.log('[ACTIVITY_COLLECTOR] 🔄 Uploading via HTTP API (fallback)');
      await this.dataSyncService.addActivityData(inputActivityData);
    }

    // 重置累积数据
    this.resetAccumulatedData();

    this.emit('data-uploaded', this.accumulatedData);

  } catch (error) {
    console.error('[ACTIVITY_COLLECTOR] Failed to upload accumulated data:', error);
    this.emit('upload-error', error);
    throw error;
  }
}
```

#### 4.2 周期重置逻辑

**位置**: activity-collector-service.ts:435-442

```typescript
private resetAccumulatedData(): void {
  this.accumulatedData = this.createEmptyActivityData();
  this.collectionStartTime = Date.now();
  this.lastActivityTime = this.collectionStartTime;
  this.isCurrentlyIdle = false;

  console.log('[ACTIVITY_COLLECTOR] Accumulated data reset');
}
```

**数据上传流程**:
```
1. 定时器触发 (每 60 秒)
     ↓
2. 检查是否有累积数据
     ↓
3. 计算实际收集时长 (actualDuration)
     ↓
4. 获取当前活动窗口信息
     ↓
5. 准备上传数据 (InputActivityData)
     - timestamp: 上传时间戳
     - isActive: true (有事件即活动)
     - keystrokes: 累积键盘次数
     - mouseClicks: 累积鼠标次数
     - idleTime: 累积空闲时间
     - activeWindow: 当前窗口标题
     - activityInterval: 实际收集时长
     ↓
6. 优先 WebSocket 上传 (实时)
     ↓ (失败)
7. HTTP API 备用上传
     ↓
8. 上传成功 → 重置所有累积数据
     - keystrokes = 0
     - mouseClicks = 0
     - activeTime = 0
     - idleTime = 0
     - collectionStartTime = now
```

---

### 5. 服务器端数据格式

**InputActivityData** (common/interfaces/service-interfaces.ts:187-196):

```typescript
export interface InputActivityData {
  timestamp: string;              // ISO 8601 格式时间戳
  isActive: boolean;              // 是否活动状态 ⭐
  keystrokes: number;             // 键盘按键次数
  mouseClicks: number;            // 鼠标点击次数
  idleTime: number;               // 空闲时间（毫秒）⭐
  activeWindow?: string;          // 活动窗口标题
  activeWindowProcess?: string;   // 活动窗口进程名
  activityInterval: number;       // 活动采集间隔（毫秒）⭐
}
```

**关键字段说明**:

1. **isActive**: 布尔值，表示此时间段内用户是否有活动
   - 计算方式: `keystrokes > 0 || mouseClicks > 0`
   - 用于快速判断用户是否在线

2. **idleTime**: 空闲时间（毫秒）
   - 从原生系统 API 获取
   - 与 activeTime 互为补充

3. **activityInterval**: 实际收集时长（毫秒）
   - 理论值: `activityInterval` (配置，默认60000ms)
   - 实际值: `now - collectionStartTime`
   - **活动时间计算公式**: `activeTime = activityInterval - idleTime`

---

## 关键发现

### 优势

✅ **真实事件捕获**
- 使用系统级别的事件钩子，非应用层模拟
- macOS: CGEventTap API
- Windows: SetWindowsHookEx API
- 数据可信度极高

✅ **双重验证机制**
- `activeTime` + `idleTime` ≈ `activityInterval`
- 事件计数 + 空闲检测互为验证
- 防止数据篡改和异常值

✅ **精确的时间累积算法**
- 基于事件触发的增量累积
- 空闲阈值防护（30秒）
- 毫秒级精度

✅ **可配置的采集策略**
- `activityInterval`: 灵活配置上报频率
- `idleThreshold`: 自定义空闲判断标准
- `enableActivity` / `enableIdleDetection`: 功能开关

✅ **跨平台一致性**
- 统一的数据结构和接口
- 平台特定实现透明封装
- 降级策略保障可用性

### 问题

⚠️ **权限依赖性强**
- macOS: 需要"辅助功能"权限
- Windows: 需要管理员权限
- 权限不足时只能使用推断模式，准确性下降

⚠️ **空闲阈值固定**
- 默认 30 秒阈值可能不适合所有场景
- 用户短暂思考（如阅读代码）可能被误判为空闲
- 建议: 提供用户自定义空闲阈值配置

⚠️ **活动时间计算不透明**
- 客户端未直接上报 `activeTime`
- 服务器需要通过 `activityInterval - idleTime` 计算
- 可能导致理解偏差

⚠️ **推断模式置信度低**
- Windows 推断模式依赖间接指标
- 置信度通常在 40%-70%
- 不适合精确计费场景

⚠️ **鼠标移动未充分利用**
- 当前鼠标移动计数但未用于活动判断
- 鼠标移动可作为辅助活动指标
- 建议: 增加鼠标移动作为活动时间计算因子

### 风险

🚨 **数据丢失风险**
- 网络中断时累积数据未持久化
- 客户端崩溃可能丢失未上传数据
- 建议: 实现本地缓存和补传机制

🚨 **时间漂移风险**
- 依赖客户端系统时间
- 用户修改系统时间可能导致数据异常
- 建议: 增加服务器时间校准机制

🚨 **性能影响**
- 全局键盘鼠标钩子可能影响系统性能
- 高频事件处理需要优化
- 当前每秒可能处理数百次事件

🚨 **隐私合规风险**
- 监控键盘鼠标需要明确的用户授权
- 需要清晰的隐私政策和数据用途说明
- 某些地区可能有法律限制

---

## 改进建议

### 高优先级

1. **增强活动时间透明度**
   - **问题**: 服务器端需要推算活动时间
   - **建议**: 客户端直接上报 `activeTime` 字段
   ```typescript
   const inputActivityData = {
     // ... 现有字段
     activeTime: this.accumulatedData.activeTime,  // 新增
     calculationMethod: 'event-based'  // 标注计算方式
   };
   ```
   - **预期收益**: 消除数据理解歧义，提高服务器端计算效率

2. **实现数据持久化机制**
   - **问题**: 网络中断或崩溃导致数据丢失
   - **建议**: 上传失败时写入本地 SQLite 或文件队列
   ```typescript
   private async uploadAccumulatedData(): Promise<void> {
     try {
       await this.sendToServer(data);
       await this.clearLocalCache(data.timestamp);
     } catch (error) {
       await this.saveToLocalCache(data);  // 持久化失败数据
       this.scheduleRetry();
     }
   }
   ```
   - **预期收益**: 数据完整性提升至 99.9%+

3. **增加服务器时间同步**
   - **问题**: 客户端时间不可信
   - **建议**: 心跳时同步服务器时间，使用时间偏移量校正
   ```typescript
   const serverTimeOffset = serverTime - Date.now();
   const correctedTimestamp = new Date(Date.now() + serverTimeOffset);
   ```
   - **预期收益**: 消除时间篡改风险

### 中优先级

4. **可配置的空闲阈值**
   - **问题**: 30秒固定阈值不灵活
   - **建议**: 提供用户或管理员配置接口
   ```typescript
   interface ActivityCollectorConfig {
     // ... 现有字段
     customIdleThreshold?: number;  // 允许自定义空闲阈值
     idleThresholdPresets: {
       'strict': 15000,    // 严格模式 15秒
       'standard': 30000,  // 标准模式 30秒
       'relaxed': 60000    // 宽松模式 60秒
     };
   }
   ```
   - **预期收益**: 适应不同工作场景需求

5. **增强鼠标移动利用**
   - **问题**: 鼠标移动未充分用于活动判断
   - **建议**: 大幅度鼠标移动作为活动指标
   ```typescript
   private handleMouseEvent(data: any): void {
     if (data.type === 'move' && data.distance > 50) {
       // 大幅度移动视为活动
       this.updateLastActivityTime();
       this.updateActiveTime();
     }
   }
   ```
   - **预期收益**: 提高对阅读、思考等低频输入活动的识别

6. **推断模式置信度上报**
   - **问题**: 推断数据可信度不明确
   - **建议**: 增加 `confidence` 和 `dataSource` 字段
   ```typescript
   const inputActivityData = {
     // ... 现有字段
     dataSource: 'native-hook' | 'wmi-inference',
     confidence: 95,  // 0-100
   };
   ```
   - **预期收益**: 服务器端可针对低置信度数据进行特殊处理

### 低优先级

7. **活动模式分析**
   - 统计用户典型活动模式
   - 识别异常活动（如脚本模拟）
   - 提供活动质量评估

8. **性能监控与优化**
   - 增加事件处理耗时监控
   - 高频事件防抖（debounce）
   - 异步批量处理

9. **隐私增强功能**
   - 提供"隐私模式"（降低采集频率）
   - 敏感时间段屏蔽（如休息时间）
   - 用户可查看和删除历史数据

---

## 技术债务评估

| 项目 | 严重程度 | 影响范围 | 建议行动 |
|------|---------|---------|---------|
| 活动时间字段未直接上报 | 中 | 数据理解和服务器计算 | 添加 `activeTime` 到上报数据结构 |
| 缺少本地数据持久化 | 高 | 数据完整性 | 实现 SQLite 或文件队列缓存 |
| 空闲阈值硬编码 | 低 | 用户体验灵活性 | 提供配置接口 |
| 推断模式准确性低 | 中 | Windows 无权限场景 | 优化推断算法，增加置信度标注 |
| 缺少时间同步机制 | 中 | 数据可信度 | 实现服务器时间校准 |
| 权限检测不完善 | 中 | 初始化流程 | 增强权限引导和降级策略 |

---

## 活动时间计算公式总结

### 客户端计算

```
// 每个采集周期（默认60秒）
activeTime = Σ (当前时间 - 上次活动时间)
             for each (键盘事件 or 鼠标事件)
             where (时间差 < 空闲阈值30秒)

idleTime = 从系统API获取的空闲时长

// 验证公式
activeTime + idleTime ≈ activityInterval (收集时长)
```

### 服务器端推算

```
// 基于上报数据推算
activeTime = activityInterval - idleTime

// 活动判断
isActive = (keystrokes > 0) || (mouseClicks > 0)

// 有效工作时长
effectiveWorkTime = Σ activeTime
                    for each period where isActive = true
```

### 示例场景计算

**场景**: 用户在60秒内的活动

```
时间轴:
00:00 - 开始采集
00:05 - 键盘输入 (5秒活跃)
00:10 - 鼠标点击 (5秒活跃)
00:15 - 开始阅读文档 (无输入)
00:45 - 恢复输入 (检测到30秒空闲)
00:50 - 鼠标点击 (5秒活跃)
01:00 - 采集周期结束

计算过程:
activeTime = 5s (00-05) + 5s (05-10) + 5s (45-50) = 15000ms
idleTime = 30000ms (15-45的空闲时间)
其他时间 = 60000 - 15000 - 30000 = 15000ms (正常活动但低于检测阈值)

上报数据:
{
  timestamp: "2025-01-16T10:01:00Z",
  isActive: true,
  keystrokes: 120,
  mouseClicks: 15,
  idleTime: 30000,
  activityInterval: 60000
}

服务器推算:
activeTime = 60000 - 30000 = 30000ms (30秒)
effectiveWorkTime = 30s (计入工作时长)
```

---

## 架构视图

### 数据流架构

```
┌──────────────────────────────────────────────────────────────┐
│                       用户操作                                 │
│            (键盘输入、鼠标点击、鼠标移动)                        │
└───────────────────┬──────────────────────────────────────────┘
                    │
                    ↓
┌──────────────────────────────────────────────────────────────┐
│                 操作系统 (OS Kernel)                          │
│         macOS: IOKit / CGEventTap                            │
│         Windows: Win32 API / SetWindowsHookEx                │
└───────────────────┬──────────────────────────────────────────┘
                    │
                    ↓
┌──────────────────────────────────────────────────────────────┐
│              原生模块 (Native Modules)                         │
│   macOS: native-event-monitor (Objective-C/Swift)            │
│   Windows: native-event-monitor-win (C++ Win32)              │
│   ┌─────────────────────────────────────────────────┐       │
│   │ 事件类型判断                                      │       │
│   │ - Keyboard Event → keystrokes++                 │       │
│   │ - Mouse Click → mouseClicks++                   │       │
│   │ - Mouse Move → mouseMoves++                     │       │
│   │ - Scroll Event → scrollEvents++                 │       │
│   └─────────────────────────────────────────────────┘       │
└───────────────────┬──────────────────────────────────────────┘
                    │
                    ↓
┌──────────────────────────────────────────────────────────────┐
│           Platform Adapters (平台适配器)                       │
│   - DarwinAdapter.createEventListener()                       │
│   - WindowsAdapter.createEventListener()                      │
│   ┌─────────────────────────────────────────────────┐       │
│   │ 事件聚合和周期计数                                │       │
│   │ currentPeriodKeystrokes += count                │       │
│   │ currentPeriodMouseClicks += count               │       │
│   └─────────────────────────────────────────────────┘       │
└───────────────────┬──────────────────────────────────────────┘
                    │
                    ↓
┌──────────────────────────────────────────────────────────────┐
│         ActivityCollectorService (业务逻辑层)                 │
│   ┌──────────────────────────────────────────────────┐      │
│   │ 事件处理器                                         │      │
│   │ - handleKeyboardEvent()                          │      │
│   │   → updateLastActivityTime()                     │      │
│   │   → updateActiveTime()                           │      │
│   │ - handleMouseEvent()                             │      │
│   │   → updateLastActivityTime()                     │      │
│   │   → updateActiveTime()                           │      │
│   │ - handleIdleStateChange()                        │      │
│   │   → 累积 idleTime                                 │      │
│   └──────────────────────────────────────────────────┘      │
│   ┌──────────────────────────────────────────────────┐      │
│   │ 活动时间计算核心                                   │      │
│   │                                                   │      │
│   │ updateActiveTime() {                             │      │
│   │   if (!isCurrentlyIdle) {                        │      │
│   │     timeDiff = now - lastActivityTime            │      │
│   │     if (timeDiff < idleThreshold) {              │      │
│   │       activeTime += timeDiff                     │      │
│   │     }                                             │      │
│   │   }                                               │      │
│   │ }                                                 │      │
│   └──────────────────────────────────────────────────┘      │
│   ┌──────────────────────────────────────────────────┐      │
│   │ 累积数据结构                                       │      │
│   │ {                                                 │      │
│   │   keystrokes: 0,                                 │      │
│   │   mouseClicks: 0,                                │      │
│   │   mouseMoves: 0,                                 │      │
│   │   scrollEvents: 0,                               │      │
│   │   activeTime: 0,        ← 核心字段                │      │
│   │   idleTime: 0,          ← 核心字段                │      │
│   │   intervalDuration: 60000,                       │      │
│   │   timestamp: Date                                │      │
│   │ }                                                 │      │
│   └──────────────────────────────────────────────────┘      │
└───────────────────┬──────────────────────────────────────────┘
                    │
                    │ (定时器: 每60秒)
                    ↓
┌──────────────────────────────────────────────────────────────┐
│              uploadAccumulatedData()                          │
│   ┌──────────────────────────────────────────────────┐      │
│   │ 数据上报格式转换                                   │      │
│   │ InputActivityData {                              │      │
│   │   timestamp: ISO8601,                            │      │
│   │   isActive: keystrokes > 0 || mouseClicks > 0,  │      │
│   │   keystrokes: number,                            │      │
│   │   mouseClicks: number,                           │      │
│   │   idleTime: number,                              │      │
│   │   activeWindow: string,                          │      │
│   │   activityInterval: actualDuration               │      │
│   │ }                                                 │      │
│   └──────────────────────────────────────────────────┘      │
└───────────────────┬──────────────────────────────────────────┘
                    │
                    ↓
         ┌─────────────────────┐
         │  WebSocket (实时)    │
         └──────────┬───────────┘
                    │ (失败)
                    ↓
         ┌─────────────────────┐
         │   HTTP API (备用)    │
         └──────────┬───────────┘
                    │
                    ↓
┌──────────────────────────────────────────────────────────────┐
│                    API Server                                │
│   ┌──────────────────────────────────────────────────┐      │
│   │ 服务器端活动时间计算                               │      │
│   │                                                   │      │
│   │ activeTime = activityInterval - idleTime         │      │
│   │                                                   │      │
│   │ effectiveWorkTime = Σ activeTime                 │      │
│   │                     where isActive = true        │      │
│   └──────────────────────────────────────────────────┘      │
└──────────────────────────────────────────────────────────────┘
```

---

## 性能指标

### 事件处理性能

| 指标 | 数值 | 说明 |
|------|------|------|
| 事件捕获延迟 | < 5ms | 从系统事件到原生模块处理 |
| 事件处理延迟 | < 10ms | 从原生模块到业务层处理 |
| 内存占用 | < 20MB | 原生模块 + 业务逻辑 |
| CPU 占用 | < 1% | 正常活动下的 CPU 占用 |
| 数据上传频率 | 60秒/次 | 可配置，默认1分钟 |
| 数据包大小 | < 1KB | 单次上传数据量 |

### 准确性指标

| 场景 | 准确率 | 说明 |
|------|-------|------|
| 原生钩子模式 | 99%+ | 有完整权限时 |
| 推断模式 (Windows) | 60-80% | 权限不足时 |
| 空闲检测 | 95%+ | 基于系统 API |
| 时间累积 | 毫秒级 | 精确到毫秒 |

---

## 安全评估

### 数据安全

✅ **数据最小化原则**
- 仅收集键盘鼠标事件计数，不记录具体按键内容
- 不捕获屏幕内容（除非单独启用截图功能）
- 窗口标题可选，可配置为仅记录进程名

✅ **传输安全**
- WebSocket 使用 TLS 加密
- HTTP API 使用 HTTPS
- 支持客户端证书认证

⚠️ **存储安全**
- 内存中的累积数据未加密
- 本地缓存（如果实现）需要考虑加密

### 隐私合规

⚠️ **用户知情同意**
- 需要明确的用户授权流程
- 隐私政策应清晰说明监控范围和数据用途
- 提供用户随时停用监控的选项

⚠️ **数据删除权**
- 用户应有权查看和删除历史活动数据
- 提供数据导出功能

⚠️ **地域合规**
- GDPR (欧盟): 需要明确的合法理由和用户同意
- CCPA (加州): 需要提供退出选项
- 中国个人信息保护法: 需要明确的告知和同意机制

---

## 学习要点

### 系统编程技术

1. **事件钩子 (Event Hooks)**
   - macOS: CGEventTap 全局事件监听
   - Windows: SetWindowsHookEx 低级钩子
   - 权限要求和安全限制

2. **跨平台抽象**
   - 统一的接口设计
   - 平台特定实现封装
   - 降级策略和错误处理

3. **原生模块集成**
   - Node.js N-API 绑定
   - C++/Objective-C/Swift 混合编程
   - 内存管理和生命周期

### 数据收集最佳实践

1. **增量累积模式**
   - 事件驱动的增量更新
   - 定时上报和数据重置
   - 防止数据丢失的持久化

2. **双重验证机制**
   - activeTime + idleTime ≈ intervalDuration
   - 事件计数 + 空闲检测
   - 置信度评估

3. **性能优化**
   - 高频事件的防抖处理
   - 异步事件处理
   - 内存和 CPU 占用控制

### 隐私与安全

1. **数据最小化**
   - 仅收集必要的聚合指标
   - 不记录敏感的具体内容
   - 提供用户控制选项

2. **透明度和同意**
   - 清晰的隐私政策
   - 明确的用户授权流程
   - 随时可停用的选项

3. **安全传输和存储**
   - TLS/HTTPS 加密传输
   - 考虑本地数据加密
   - 访问控制和审计日志

---

## 参考资源

### 技术文档

- **macOS CGEventTap**: [Apple Developer - Quartz Event Services](https://developer.apple.com/documentation/coregraphics/quartz_event_services)
- **Windows Hooks**: [Microsoft Docs - SetWindowsHookEx](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowshookexw)
- **Node.js N-API**: [Node.js Documentation - N-API](https://nodejs.org/api/n-api.html)

### 最佳实践

- **Activity Tracking Best Practices**: [Web Monitoring Guidelines](https://www.w3.org/TR/monitoring/)
- **Privacy by Design**: [Privacy Principles](https://www.ipc.on.ca/wp-content/uploads/Resources/7foundationalprinciples.pdf)
- **GDPR Compliance**: [European Commission GDPR Portal](https://ec.europa.eu/info/law/law-topic/data-protection_en)

### 技术标准

- **ISO/IEC 27001**: 信息安全管理体系
- **NIST Cybersecurity Framework**: 网络安全框架
- **OWASP Top 10**: Web 应用安全风险

---

**分析完成时间**: 2025-01-16
**文档版本**: v1.0
**分析师**: Claude Code AI Assistant
